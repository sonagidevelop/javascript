////////////////////scoping
음...이해한 것과 크게 다르지는 않았는데
reassigning outer scope's variable 이 부분이 신기했다.
output을 그냥 declare 하는거랑 const놓고 declare하는거랑 결과가 아예 달랐다.
const놓고 declare하면 같은 이름이지만 아예 다른 변수인 것이 신기했다.

////////////////////호이스팅
var me = 'jinhyeok';  //undefined로 hoist된다.
let job = 'soldier';   //ReferenceError뜬다.
const year = 1998;

//functions
// console.log(addDecl(2, 3));
// console.log(addExpr(2, 3)); //ReferenceError 인데 var로 놓고 하면 함수가 아니라고 한다.
// console.log(addArrow(2, 3)); // 이유는 hoisted면 undefined이기 때문이다

// function addDecl(a, b) {
//     return a + b;
// }

// const addExpr = function (a, b) { //ReferenceError
//     return a + b;
// }

// var addArrow = (a, b) => a + b; //TypeError

//examples

if (!numProducts) deleteShoppingCart(); //hoisting하면 undefined라서 falsy value임.

var numProducts = 10;

function deleteShoppingCart() {
    console.log('all products deleted');
}

var x = 1;
let y = 2;
const z = 3;

console.log(z === window.z);
//variables declared with var create a property on window.


///////////////////////////////// this 키워드
THIS KEYWORD/VARIABLE
:special variable that is created for every execution context(every function).Takes the value of (points to)
the "owner" of the function in which the this keyword is used.
execution context(모든 함수)에게 생성되는 특별한 변수. this키워드가 쓰이는 함수의 "주인"의 값을 가진다(가리킨다).

this is not static. It depends on how the function is called, and its value is only assigned when the function 
is actually called.
이건 정적이지 않다. 이건 함수가 어떻게 호출되느냐에 의존하며, 이것의 값은 오직 실제로 호출됐을 때만 할당된다.

**4 Ways of calling functions
    -method:this=<object that is calling the method>메소드를 호출하는 함수가 this이다.
    -simple call:this=undefined(in strict mode. else: window)
    -arrow functions: this =<this of surrounding function> (lexical this)부모 함수의 this가 this이다.
    -Event Listener: this=<DOM element that the handler is attatched to>핸들러가 붙어있는 dom 요소가 this이다.
    -new,call,apply,bind도 있는데 나중에 배움.
    
this does not point to the function itself, and also not the variable environment!
this는 함수 자체를 가리키는 것이아니며, 변수 환경을 가리키는 것도 아니다.





const calcAge = function (birtyYear) {
    console.log(2020 - birtyYear);
    console.log(this);
}

calcAge(1998);

const calcAgeArrow = birtyYear => {
    console.log(2020 - birtyYear);
    console.log(this);
}

calcAgeArrow(1990);

const jonas = {
    year: 1991,
    calcAge: function () {  //method에서의 this는 attatching object다.
        console.log(this);
        console.log(2037 - this.year);
    }
};
jonas.calcAge();

const matilda = {
    year: 2017,
};

matilda.calcAge = jonas.calcAge;  //method borrowing
matilda.calcAge();

const f = jonas.calcAge; //이렇게하면 simple function call임.
f();
